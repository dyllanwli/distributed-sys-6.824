## 2. 上下的抽象层次


在这一章中，我们将在抽象层次上下游，观察一些不可能的结果（CAP和FLP），然后为了表现而返回。

如果你已经做了任何编程，抽象层次的概念可能是你所熟悉的。 您将始终在某个抽象层次上工作，通过一些API与较低层次的接口进行交互，并可能为您的用户提供一些更高级别的API或用户界面。 计算机网络的七层OSI模型就是一个很好的例子。

分布式编程是我主张的，很大程度上是处理分配的后果。 也就是说，现实中有很多节点和我们对“像单一系统一样工作”的系统的愿望之间存在紧张关系。 这意味着要寻找一种能够平衡什么是可以理解和表现的好抽象。

说X比Y更抽象是什么意思？ 首先，X不会引入任何新的或与Y有根本区别的东西。事实上，X可能会删除Y的某些方面，或者以使它们更易于管理的方式呈现它们。 其次，从某种意义上说，X比Y更易于理解，假设X从Y中移除的东西对于手头的事情并不重要。

正如尼采所写：

    每一个概念都源于我们把不平等的东西等同起来。 没有一个叶子完全等于另一个叶子，而“叶子”这个概念是通过对这些个体差异的任意抽象而形成的，通过忘记差别而形成; 现在它引发了这样的想法：在自然界中除了叶子之外可能还有一些东西会成为“叶子” - 一种原来的形式，之后所有的叶子都被编织，标记，复制，着色，卷曲和绘画。通过不熟练的手，以致没有任何拷贝成为原始形式的正确，可靠和忠实的形象

抽象从根本上说是假的。 每个情况都是独一无二的，每个节点也是如此 但抽象使世界易于管理：更简单的问题陈述 - 脱离现实 - 更易于分析，而且假定我们没有忽视任何必要的东西，解决方案是广泛适用的。

事实上，如果我们所处的东西是必不可少的，那么我们可以得出的结果将是广泛适用的。 这就是不可能性结果如此重要的原因：它们尽可能简单地表达一个问题，并且证明在一些约束或假设下解决是不可能的。

所有的抽象都忽略了一些有利于等同于事实上独一无二的东西。 诀窍是摆脱一切不是必需的。 你怎么知道什么是必不可少的？ 那么，你可能不会先知道。

每当我们从系统规范中排除某个系统的某个方面时，我们就冒着引入错误和/或性能问题的风险。 这就是为什么有时候我们需要走向另一个方向，有选择地将真实硬件的一些方面和现实世界的问题带回来。 重新引入一些特定的硬件特性（例如物理顺序性）或其他物理特性来获得足够好的系统就足够了。

考虑到这一点，在仍然可以识别分布式系统的东西的同时，我们可以保留的最少量的现实是什么？ 系统模型是我们认为重要的特征的规范; 指定了一个，我们可以看看一些不可能的结果和挑战。

### 一个系统模型

分布式系统的一个关键特性是分布式。 更具体地说，分布式系统中的程序：

    在独立节点上同时运行...
    由可能引入不确定性和消息丢失的网络连接...
    并没有共享内存或共享时钟。

有很多含义：

    每个节点同时执行一个程序
    知识是本地的：节点只能快速访问本地状态，任何有关全局状态的信息都可能过时
    节点可能会失败并独立地从故障中恢复
    消息可能会延迟或丢失（与节点故障无关;区分网络故障和节点故障并不容易）
    并且时钟在节点之间不同步（本地时间戳不对应于全球实时顺序，这不容易被观察到）

系统模型列举了与特定系统设计相关的许多假设。


系统模型对环境和设施的假设各不相同。 这些假设包括：

    节点具有哪些功能以及它们可能会失败
    沟通链接如何运作，以及他们如何失败
    整个系统的性质，如时间和秩序的假设
一个强大的系统模型是一个最弱的假设：为这样的系统编写的任何算法对于不同的环境都是非常宽容的，因为它使得很少和很弱的假设。

另一方面，我们可以通过强有力的假设建立一个容易推理的系统模型。 例如，假设节点不失败意味着我们的算法不需要处理节点失败。 但是，这样的制度模式是不现实的，难以应用于实践。

我们来看看节点的属性，链接以及时间和顺序。

### 我们的系统模型中的节点

节点充当计算和存储的主机。 他们有：

    执行程序的能力
    将数据存储到易失性存储器（可能会在失败时丢失）并进入稳定状态（可以在失败后读取）的能力，
    一个时钟（可能会或可能不会被认为是准确的）
节点执行确定性算法：本地计算，计算后的本地状态以及发送的消息由接收到的消息唯一确定，消息接收时则由本地状态确定。

有许多可能的故障模型，描述节点可能发生故障的方式。 在实践中，大多数系统都假设了一个崩溃恢复失败模型：也就是说，节点只能通过崩溃失败，并且在稍后的某个点崩溃后可能（可能）恢复。

另一种选择是假设节点可能会以任意方式行为失败。 这就是所谓的拜占庭容错 。 拜占庭式故障很少在现实世界的商业系统中处理，因为适应任意故障的算法运行成本更高，实现起来更复杂。 我不会在这里讨论。

### 通信链接在我们的系统模型中

通信链路将各个节点彼此连接起来，并允许消息以任一方向发送。 许多讨论分布式算法的书籍假设每对节点之间存在单独的链接，链接为消息提供先进先出（FIFO）顺序，它们只能发送已发送的消息，发送的消息可以是丢失。

一些算法假定网络是可靠的：消息永远不会丢失，永远不会无限期延迟。 这对于一些现实世界的设置可能是一个合理的假设，但总的来说，考虑网络是不可靠的并且受到信息丢失和延迟是优选的。

当网络发生故障时，网络分区发生，而节点本身保持运行。 发生这种情况时，邮件可能会丢失或延迟，直到网络分区修复。 一些客户端可以访问分区节点，因此必须与崩溃节点区别对待。 下图说明了节点故障与网络分区的关系：

![](http://book.mixu.net/distsys/images/system-of-2.png)

对通信链接做进一步的假设是很少见的。 我们可以假设链接只能在一个方向上工作，或者我们可以为不同的链接引入不同的通信成本（例如，由于物理距离造成的延迟）。 然而，除了长距离链路（WAN延迟）之外，这些在商业环境中很少受到关注，所以我不在这里讨论。 成本和拓扑的更详细的模型允许以复杂性为代价来更好地进行优化。

### 定时/订购假设

物理分配的后果之一是每个节点都以独特的方式体验世界。 这是不可避免的，因为信息只能以光速行进。 如果节点距离彼此不同，则从一个节点发送到另一个节点的任何消息将在不同的时间到达，并且在其他节点处可能以不同的顺序到达。

时间假设是捕捉关于我们考虑到这种现实的程度的一个简便的速记。 两个主要的选择是：

    同步系统模型
    进程以锁步方式执行; 消息传输延迟有一个已知的上界; 每个进程都有一个精确的时钟
    异步系统模型
    没有时间假设 - 例如流程以独立的费率执行; 消息传输延迟没有限制; 有用的时钟不存在

同步系统模型对时间和顺序施加了许多限制。 它基本上假设节点具有相同的体验：发送的消息总是在特定的最大传输延迟内被接收，并且这些过程以锁步执行。 这很方便，因为它允许你作为系统设计者对时间和顺序进行假设，而异步系统模型则不然。

异步性是一个非假设：它只是假定你不能依靠时间（或“时间传感器”）。

在同步系统模型中解决问题比较容易，因为关于执行速度，最大消息传输延迟和时钟准确度的假设都有助于解决问题，因为您可以基于这些假设作出推断，并通过假设它们从不发生而排除不方便的故障情况。

当然，假定同步系统模型不是特别现实的。 真实世界的网络会出现故障，消息延迟也没有困难。 现实世界中的系统最好是部分同步的：它们偶尔可以正常工作，并提供一些上限，但是有时会无限期地延迟消息，并且时钟不同步。 我不会在这里讨论同步系统的算法，但是你可能会在其他许多入门书籍中遇到它们，因为它们在分析上更容易（但不现实）。



### 共识问题

在本文的其余部分，我们将改变系统模型的参数。 接下来，我们将看看如何改变两个系统属性：

    无论网络分区是否包含在故障模型中，以及
    同步与异步时序假设

通过讨论两个不可能性结果（FLP和CAP）来影响系统设计选择。

当然，为了讨论，我们还需要介绍一个问题来解决。 我要讨论的问题是共识问题 。

如果几个计算机（或节点）都同意某些价值，就会达成共识。 更正式地说：

    协议：每个正确的过程必须达成一致的价值。
    诚信：每一个正确的过程至多决定一个价值，如果它决定了一些价值，那么它一定是由某个过程提出来的。
    终止：所有进程最终都会做出决定。
    有效性：如果所有正确的过程提出相同的值V，则所有正确的过程决定V.

共识问题是许多商业分布式系统的核心。 毕竟，我们需要分布式系统的可靠性和性能，而不必处理分布的后果（例如节点之间的分歧/分歧），解决共识问题可以解决一些相关的，更高级的问题，比如原子广播和原子提交。

### 两个不可能的结果

第一个不可能的结果，被称为FLP不可能性结果，是一个不可能的结果，与设计分布式算法的人特别相关。 第二个 - CAP定理 - 是一个与实践者更相关的相关结果; 需要在不同的系统设计之间进行选择，而不是直接关心算法设计的人。


### FLP不可能的结果

我只是简要地总结一下FLP不可能的结果 ，尽管它在学术界被认为是比较重要的 。 FLP不可能性结果（以作者Fischer，Lynch和Patterson的名字命名）考察异步系统模型（技术上说，协议问题，这是一个非常薄弱的​​共识问题）下的共识问题。 假设节点只能通过崩溃失败; 网络是可靠的，异步系统模型的典型时序假设是：例如，消息延迟没有界限。

在这些假设下，FLP结果指出：“即使消息永远不会丢失，也不存在针对异步系统中的共识问题的（确定性）算法，最多一个进程可能会失败，并且只能崩溃（停止执行）“失败。

这个结果意味着在一个非常微小的系统模型下无法解决共识问题的方式是不能永久延迟的。 这个论点是，如果存在这样的算法，那么可以通过延迟消息传递来设计执行该算法，在该算法中它将保持未定（“二价”）任意时间量，这在异步系统模型中是允许的。 因此，这样的算法不能存在。

这种不可能的结果是非常重要的，因为它突出了假设异步系统模型导致了一个折衷：解决共识问题的算法必须放弃安全性或活跃性，当关于消息传递的界限的保证不成立时。

这种见解与设计算法的人特别相关，因为它对我们知道在异步系统模型中可以解决的问题施加了严格的限制。 CAP定理是一个与从业者更相关的相关定理：它做出了稍微不同的假设（网络故障而不是节点故障），并且对于从业者在系统设计之间进行选择具有更明确的含义。

### CAP定理

CAP定理最初是计算机科学家Eric Brewer的猜想。 在系统设计所提供的保证中考虑权衡是一种流行且相当有用的方法。 它甚至有吉尔伯特和林奇的正式证明 ，不， 纳森·马尔兹没有揭穿它，尽管一个特定的讨论网站认为。

这个定理说明了这三个性质：

    一致性：所有节点同时看到相同的数据。
    可用性：节点故障不会阻止幸存者继续操作。
    分区容错：尽管由于网络和/或节点故障造成的信息丢失，系统仍可继续运行

只有两个可以同时满足。 我们甚至可以把它画成一个漂亮的图，从三个中挑选两个属性给我们三种对应于不同交叉点的系统：

![](http://book.mixu.net/distsys/images/CAP.png)

请注意，这个定理指出，中间件（具有所有三个属性）是不可实现的。 然后我们得到三种不同的系统类型：

    CA（一致性+可用性）。 例子包括完全严格的仲裁协议，如两阶段提交。
    CP（一致性+分区容差）。 示例包括少数分区不可用的大多数法定人数协议，例如Paxos。
    AP（可用性+分区容差）。 示例包括使用冲突解决方案的协议，如Dynamo。
CA和CP系统设计都提供相同的一致性模型：强一致性。 唯一的区别是CA系统不能容忍任何节点故障; 一个CP系统在非拜占庭故障模型中可以容忍多达2f+1节点的故障（换句话说，只要多数f+1保持不变，它就可以容忍少数f个节点的故障）。 原因很简单：

    CA系统不区分节点故障和网络故障，因此必须停止接受各处的写入以避免引入分歧（多个副本）。 它不能分辨出远程节点是否关闭，或者只是网络连接断开，所以唯一安全的就是停止接受写入。
    CP系统通过在分区的两侧强制不对称行为来防止分歧（例如，保持单拷贝一致性）。 它只保留大部分分区，并且要求少数分区变得不可用（例如停止接受写入），其保留一定程度的可用性（大部分分区），并且仍然确保单拷贝一致性。

在讨论Paxos时，我将在复制一章中更详细地讨论这个问题。 重要的是，CP系统将网络分区合并到他们的故障模型中，并使用Paxos，Raft或视图加盖复制等算法来区分大多数分区和少数分区。 CA系统不具备分区感知能力，而且历史上更为常见：它们通常使用两阶段提交算法，并且在传统的分布式关系数据库中很常见。

假定发生分区，则定理在可用性和一致性之间减少为二元选择。

我认为应该从CAP定理中得出四个结论：

首先， 在早期的分布式关系数据库系统中使用的许多系统设计没有考虑分区容差 （例如，它们是CA设计）。 分区容忍是现代系统的一个重要属性，因为如果系统在地理上分布（像许多大型系统一样），则网络分区变得更有可能。

其次， 在网络分区期间强大的一致性和高可用性之间存在紧张关系 。 CAP定理是在强保证和分布式计算之间进行权衡的一个例证。
- - -

从某种意义上说，承诺一个由不可预知的网络连接的独立节点组成的分布式系统的行为方式与非分布式系统无法区分是相当疯狂的。

强一致性保证要求我们在分区期间放弃可用性。 这是因为不能防止两个不能彼此通信的副本之间的分歧，同时继续接受分区两侧的写入。

我们如何解决这个问题？ 通过加强假设（假设不分割）或削弱保证。 一致性可以根据可用性（以及离线可访问性和低延迟的相关能力）进行权衡。 如果“一致性”被定义为小于“所有节点同时看到相同数据”的东西，那么我们可以同时具有可用性和一些（较弱）一致性保证。
- - -

第三， 在正常运行中，一致性和性能之间存在紧张关系 。

强一致性/单拷贝一致性要求节点进行沟通并就每个操作达成一致。 这导致正常操作中的高延迟。

如果您可以使用一种非经典模式的一致性模型，一种允许副本滞后或发散的一致性模型，则可以减少正常操作期间的延迟，并在存在分区的情况下保持可用性。

当涉及更少的消息和更少的节点时，操作可以更快地完成。 但要做到这一点，唯一的办法就是放松保证：让一些节点不要频繁地联系，这意味着节点可以包含旧数据。

这也使得发生异常成为可能。 你不再保证获得最新的价值。 根据所做的保证类型，您可能会读取比预期更久的值，甚至会丢失一些更新。

第四 - 也有些间接 - 如果我们不希望在网络分区期间放弃可用性，那么我们需要探究一致性模型除强一致性之外是否对我们的目的可行 。

例如，即使用户数据被复制到多个数据中心，并且这两个数据中心之间的链接暂时失灵，但在很多情况下，我们仍然希望允许用户使用网站/服务。 这意味着稍后调和两组不同的数据，这既是技术挑战，又是商业风险。 但是技术挑战和业务风险往往都是可以管理的，所以最好提供高可用性。

一致性和可用性并不是真正的二元选择，除非你把自己限制在一致性强的地方。 但强一致性只是一种一致性模型：您必须放弃可用性才能防止数据的单个副本处于活动状态。 正如布鲁尔所指出的那样 ，“ 三分之二 ”的解释是误导性的。

如果你从这个讨论中拿走一个主意，让它成为这个：“一致性”不是一个单一的，明确的属性。 记得：

    ACID 一致性

相反，一致性模型是数据存储提供给使用它的程序的保证 - 任何保证。

    一致性模型
    程序员和系统之间的合同，其中系统保证如果程序员遵循一些特定的规则，数据存储器上的操作结果将是可预测的

CAP中的“C”是“强一致性”，但“一致性”不是“强一致性”的同义词。

我们来看看一些可选的一致性模型。

### 与其他一致性模型的一致性较强

一致性模型可以分为两类：强一致性模型和弱一致性模型：

    强一致性模型（能够维护一个副本）
        线性化的一致性
        连续一致性
    弱一致性模型（不强）
        以客户为中心的一致性模型
        因果一致性：可用的最强的模型
        最终的一致性模型

强一致性模型保证更新的表面顺序和可见性相当于非复制系统。 另一方面，弱一致性模型不能做出这样的保证。

请注意，这绝不是一个详尽的清单。 再次强调，一致性模型只是程序员和系统之间的任意合约，所以他们几乎可以做任何事情。

### 强一致性模型

强一致性模型可以进一步划分为两个相似但略有不同的一致性模型：

    线性化一致性 ：在可线性化一致性下，所有操作似乎都按照与全局实时操作顺序一致的顺序原子地执行。 （Herlihy＆Wing，1991）
    顺序一致性 ：在顺序一致性下，所有的操作似乎都以某种顺序自动执行，与在单个节点上看到的顺序一致，并且在所有节点上都是相同的。 （Lamport，1979）
关键的区别是可线性化的一致性要求操作的生效顺序等于操作的实际实时顺序。 只要在每个节点上观察到的顺序保持一致，顺序一致性就允许对操作进行重新排序。 有人可以区分这两者的唯一方法是如果他们能够观察进入系统的所有输入和计时; 从客户端与节点交互的角度来看，两者是等价的。

这种差异似乎并不重要，但值得注意的是，顺序一致性不构成。

强一致性模型允许您作为程序员用分布式节点集群替换单个服务器，而不会遇到任何问题。

所有其他的一致性模型都有异常（与保证强一致性的系统相比），因为它们的行为方式与非复制系统有区别。 但是这些异常常常是可以接受的，要么是因为我们不关心偶然的问题，或者是因为我们已经编写了代码，以某种方式处理不一致的问题。

请注意，对于弱一致性模型，实际上没有任何通用的类型，因为“不是一个强一致性模型”（例如“以某种方式可以与非复制系统区分开来”）几乎可以是任何东西。

### 以客户为中心的一致性模型

以客户为中心的一致性模型是以某种方式涉及客户端或会话概念的一致性模型。 例如，以客户端为中心的一致性模型可能会保证客户端永远不会看到数据项的旧版本。 这通常通过在客户端库中构建额外的缓存来实现，因此，如果客户端移动到包含旧数据的副本节点，则客户端库将返回其缓存值，而不是来自副本的旧值。

如果它们所在的副本节点不包含最新版本，但客户端可能仍然会看到旧版本的数据，但是它们永远不会看到旧版本值重新出现的异常（例如，因为它们连接到不同的副本）。 请注意，有许多种以客户为中心的一致性模型。

### 最终的一致性

最终的一致性模型说，如果你停止改变数值，那么经过一些不确定的时间后，所有的副本都会达到同样的数值。 这意味着在这之前，复制品之间的结果是不一致的。 由于它是可以满足的 （只有活性属性），没有补充信息是没用的。

说一句话最终只是说“人最终死了”。 这是一个非常微弱的约束，我们可能希望至少有一些更具体的表征两件事情：

首先，“最终”多久？ 有一个严格的下界是有用的，或者至少有一些想法，说明系统通常需要多长时间才能收敛到相同的价值。

其次，复制品如何在价值上达成一致？ 始终返回“42”的系统最终是一致的：所有副本都在相同的值上达成一致。 它只是不会收敛到一个有用的值，因为它只是保持返回相同的固定值。 相反，我们想更好地了解这个方法。 例如，一种决定方法是让最大时间戳的值始终获胜。

所以当供应商说“最终的一致性”时，他们所说的是一个更为精确的术语，比如“最后一个赢家”和“最新观察值”。 “怎么样？” 因为不好的方法会导致写入丢失，例如，如果一个节点上的时钟设置不正确，并且使用时间戳。

在关于弱一致性模型复制方法的章节中，我将更详细地研究这两个问题。