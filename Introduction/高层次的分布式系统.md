## 1. 高层次的分布式系统

分布式编程是解决同一个问题的艺术，您可以使用多台计算机在一台计算机上解决这个问题。

任何计算机系统都需要完成两项基本任务：

    存储和
    计算

分布式编程是解决同一个问题的艺术，您可以在一台使用多台计算机的计算机上解决这个问题 - 通常是因为问题不再适合单台计算机。

没有什么要求您使用分布式系统。 如果有无限的资金和无限的研发时间，我们不需要分布式系统。 所有的计算和存储都可以在一个魔术盒上完成 - 一个单一的，令人难以置信的快速和令人难以置信的可靠的系统，当然需要有钱。

但是，很少有人拥有无限的资源。 因此，他们必须在现实世界的成本效益曲线上找到合适的位置。 小规模升级硬件是一个可行的策略。 但是，随着问题的增加，您可能会遇到硬件升级问题，使您无法在单个节点上解决问题，或者成本过高。 那时候，我欢迎你来到分布式系统的世界。

目前的现实情况是，最好的价值在于中端的商品硬件 - 只要通过容错软件降低维护成本。

计算主要受益于高端硬件，以至于可以用内部存储器访问来取代缓慢的网络访问。 高端硬件的性能优势在节点之间需要大量通信的任务中受到限制。


从[Barroso](http://www.morganclaypool.com/doi/abs/10.2200/S00516ED2V01Y201306CAC024)的图可以看出，高端硬件和商品硬件之间的性能差距随着集群大小的减小而减小，假设所有节点都采用统一的内存访问模式。

理想情况下，增加一台新机器将会线性增加系统的性能和容量。 但是这当然是不可能的，因为有分开的计算机会产生一些开销。 数据需要复制，计算任务必须协调等等。 这就是为什么研究分布式算法是值得的 - 它们为特定的问题提供了有效的解决方案，以及关于什么是可能的，正确实施的最低成本以及什么是不可能的。

本文的重点是分布式编程和系统，但却与商业相关：数据中心。 例如，我不会讨论具有奇特网络配置或共享内存设置中出现的特殊问题。 此外，重点是探索系统设计空间，而不是优化任何特定的设计 - 后者是一个更专业化的文本的主题。

### 我们想要实现的：可伸缩性和其他好东西

我看到它的方式，一切都始于需要处理大小。

大多数事情都是微不足道的 - 一旦你超过了一定的规模，体积或其他身体上受限制的东西，同样的问题变得更加困难。 拿起一块巧克力很容易，很难抬起一座山。 很容易计算一个房间里有多少人，很难指望一个国家有多少人。

所以一切都从尺寸开始 - 可扩展性。 非正式的说，在我们从小到大的一个可扩展的系统中，事情不应该逐渐变坏。 这是另一个定义：

    可扩展性
    是系统，网络或过程的能力，以有能力的方式处理越来越多的工作，或者扩大其能力以适应这种增长。
    
什么是增长？ 那么，你可以衡量几乎任何条件的增长（人数，用电量等）。 但有三个特别有趣的事情要看：

    大小可扩展性：增加更多的节点应该使系统线性更快​​; 增长数据集不应该增加延迟
    地理可扩展性：应该可以使用多个数据中心来减少响应用户查询所需的时间，同时以一些合理的方式处理交叉数据中心延迟。
    管理可扩展性：增加更多节点不应增加系统的管理成本（例如管理员与机器的比率）。

当然，在一个真正的系统中同时发生在多个不同的轴上， 每个指标都只是捕捉增长的一些方面。

随着规模的扩大，可扩展的系统将继续满足用户的需求。 有两个特别相关的方面 - 性能和可用性 - 可以用不同的方式衡量。

### 性能（和延迟）

    性能
    其特点是与使用的时间和资源相比，计算机系统完成的有用工作量。
    
根据具体情况，这可能涉及实现以下一项或多项内容：

    对于给定的工作，响应时间短/延迟低
    高吞吐量（处理工作的速度）
    计算资源利用率低

在优化这些结果方面存在折衷。 例如，系统可以通过处理大批量的工作来实现更高的吞吐量，从而减少操作开销。 由于配料的原因，单个工作的响应时间会更长。

我发现低延迟 - 达到一个短的响应时间 - 是性能最有趣的方面，因为它与物理（而不是财务）限制有很强的联系。 使用财务资源处理延迟比其他方面的绩效更难。

关于延迟的定义有很多，但我真的很喜欢这个词的词源：

    潜伏
    潜伏状态 延迟，从某事到事件发生之间的一段时间。

而这是什么意思是“潜伏”？

    潜
    从拉丁语latens开始，latentis是lateo的现在分词（“lie hidden”）。 存在或存在但隐藏或不活动。

这个定义非常酷，因为它突出显示了延迟是发生什么事情的时间和影响或变得可见的时间之间的时间。

例如，假设你感染了一种能将人变成僵尸的空中病毒。 潜伏期是你感染的时间和变成僵尸之间的时间。 这就是延迟：已经发生的事情被隐藏起来的时间。

假设我们的分布式系统只执行一个高级任务：给定一个查询，它将获取系统中的所有数据并计算单个结果。 换句话说，将分布式系统看作是能够在当前内容上运行单一确定性计算（函数）的数据存储：

    result = query(all data in the system)

那么，对于延迟而言，重要的不是旧数据的数量，而是系统中新数据“生效”的速度。 例如，等待时间可以通过读取可见的时间来衡量。

基于这个定义的另一个关键点是，如果什么都没有发生，就没有“潜伏期”。 数据不会改变的系统不会（或不应该）有延迟问题。

在分布式系统中，存在一个无法克服的最小延迟：光速限制了信息传输的速度，而且硬件组件每个操作（认为RAM和硬盘驱动器以及CPU）的延迟成本最小。

最小延迟对查询的影响取决于这些查询的性质以及信息需要传输的物理距离。

### 可用性（和容错）

可扩展系统的第二个方面是可用性。

    可用性
    系统处于运行状态的时间比例。 如果用户无法访问系统，则说它是不可用的。

分布式系统使我们能够实现在单个系统上难以完成的理想特性。 例如，一台机器不能容忍任何失败，因为它或者失败或者不失败。

分布式系统可能需要大量不可靠的组件，并在其上构建一个可靠的系统。

没有冗余的系统只能和它们的基础组件一样可用。 用冗余构建的系统可以容忍部分故障，从而更加可用。 值得注意的是，“冗余”可能意味着不同的东西，取决于你所看到的 - 组件，服务器，数据中心等等。

    公式上，可用性是： Availability = uptime / (uptime + downtime) 。

技术上的可用性主要是容错。 由于发生故障的可能性随着部件数量的增加而增加，所以系统应该能够进行补偿，从而不会随着部件数量的增加而变得不可靠。

例如：

    可用性 ％	每年允许多少停机时间？
    90％（“一九”）	一个多月
    99％（“两个九”）	少于4天
    99.9％（“三个九”）	不到9小时
    99.99％（“四个九”）	不到一个小时
    99.999％（“五个九”）	〜5分钟
    99.9999％（“六个九”）	〜31秒

在某种意义上，可用性是一个比正常运行时间更广泛的概念，因为服务的可用性也会受到网络中断或拥有该服务的公司的影响（这可能是一个并不相关的因素容错，但仍然会影响系统的可用性）。 但是，如果不知道系统的每个具体方面，我们所能做的就是设计容错。

这是什么意思是容错？

    容错
    一旦发生故障，系统能够以明确的方式运行

容错归结为：定义你期望的故障，然后设计一个容忍他们的系统或算法。 你不能容忍你没有考虑到的错误。

### 什么阻止我们取得好成绩？

分布式系统受到两个物理因素的制约：

    节点的数量（随着所需的存储和计算容量而增加）
    节点之间的距离（信息传播，最好在光速下）

在这些限制下工作：

    独立节点数量的增加会增加系统故障的可能性（降低可用性并增加管理成本）
    独立节点数量的增加可能增加节点之间通信的需求（随着规模增加而降低性能）
    地理距离的增加增加了远程节点之间通信的最小等待时间（降低某些操作的性能）

除了这些由于物理约束而产生的倾向之外，系统设计选择的世界。

性能和可用性都由系统所提供的外部保证来定义。 从更高的层面来说，您可以将保证视为系统的SLA（服务级别协议）：如果我写数据，我可以在其他地方多快访问它？ 数据写完后，我有什么保证有耐久性？ 如果我要求系统运行一个计算，它将多快返回结果？ 当组件出现故障或停止运行时，这对系统会有什么影响？

还有另外一个标准，这个标准没有明确的提到，但暗含着：可理解性。 这些保证是可以理解的吗？ 当然，对于什么是可理解的，没有简单的指标。

我有点想把“可理解性”置于实际的限制之下。 毕竟，对于人来说，这是一个硬件限制，我们很难理解任何涉及更多东西的东西，而不是我们的手指 。 这是错误和异常之间的区别 - 错误是不正确的行为，而异常是意想不到的行为。 如果你更聪明，你会期望异常发生。

### 抽象和模型

这是抽象和模型的作用。 抽象通过消除与解决问题无关的现实世界，使事情更易于管理。 模型以精确的方式描述分布式系统的关键属性。 我将在下一章讨论多种模型，比如：

    系统模型（异步/同步）
    失败模式（崩溃失败，分区，拜占庭）
    一致性模型（强大的，最终的）

良好的抽象使得系统的工作更容易理解，同时捕捉与特定目的相关的因素。

现实中存在着许多节点和我们对“像单一系统一样工作”的系统的愿望之间存在紧张关系。 通常，最熟悉的模型（例如，在分布式系统上实现共享内存抽象）太昂贵了。

一个做出较弱保证的制度有更多的行动自由，因此可能会有更大的表现 - 但是也可能很难推理。 人们更喜欢推理像单一系统一样工作的系统，而不是一系列节点。

人们通常可以通过揭露系统内部的更多细节来获得性能。 例如，在列式存储中 ，用户可以（在一定程度上）推理系统内键值对的位置，从而做出影响典型查询性能的决定。 隐藏这些细节的系统更容易理解（因为它们更像是单个单元，更少的细节需要考虑），而暴露更多真实世界细节的系统可能更具性能（因为它们更接近实际） 。

几种类型的故障使得编写像单个系统一样的分布式系统变得困难。 网络延迟和网络分区（例如，一些节点之间的网络总体故障）意味着系统有时需要做出艰难的选择，是否保持可用性更好，但是失去了一些不能执行的重要保证，或者安全地玩，并拒绝客户端当这些类型的故障发生时。

CAP定理 - 我将在下一章讨论 - 捕捉这些紧张的一些。 最后，理想的系统既能满足程序员的需求（干净的语义）又能满足业务需求（可用性/一致性/延迟）。

### 设计技巧：分区和复制

数据集在多个节点之间分布的方式非常重要。 为了进行任何计算，我们需要找到数据，然后采取行动。

有两种可以应用于数据集的基本技术。 它可以分成多个节点（分区）以允许更多的并行处理。 它也可以复制或缓存在不同的节点上，以减少客户端和服务器之间的距离，并提高容错能力（复制）。

#### 分而治之 - 我的意思是分割和复制。

下图说明了这两者之间的区别：分区数据（下面的A和B）被分成独立的集合，而复制的数据（下面的C）被复制到多个位置。

![](http://book.mixu.net/distsys/images/part-repl.png)

分区和复制

这是解决分布式计算发挥作用的一个问题。 当然，诀窍在于为您的具体实施选择正确的技术。 有很多实现复制和分区的算法，每个算法都有不同的限制和优势，需要根据您的设计目标进行评估。

### 分区

分区是将数据集分成更小的独立的独立集合; 这是用来减少数据集增长的影响，因为每个分区是数据的一个子集。

    分区通过限制要检查的数据量和在相同分区中定位相关数据来提高性能
    分区通过允许分区独立故障来提高可用性，增加了在牺牲可用性之前需要失败的节点数量

分区也是特定于应用程序的，所以在不知道具体细节的情况下很难多说。 这就是为什么重点放在大多数文本的复制，包括这一个。

分区主要是根据您认为的主要访问模式定义您的分区，并处理来自具有独立分区的限制（例如跨分区的低效访问，不同的增长率等）。

### 复制

复制正在多台机器上复制相同的数据; 这允许更多的服务器参与计算。

让我不准确地引用荷马辛普森 ：

    复制！ 所有生活问题的原因和解决方案。

复制 - 复制或再现某些东西 - 是我们可以对抗延迟的主要方式。

    复制通过提供适用于新数据副本的额外计算能力和带宽来提高性能
    通过创建数据的其他副本，复制可提高可用性，从而在牺牲可用性之前增加需要失败的节点数量

复制是关于提供额外的带宽和缓存在哪里。 根据一些一致性模型，也是以某种方式保持一致性的。

复制使我们能够实现可伸缩性，性能和容错性。 害怕可用性降低或性能下降？ 复制数据以避免瓶颈或单点故障。 计算缓慢？ 复制多个系统上的计算。 慢I/O？ 将数据复制到本地缓存，以减少延迟或在多台机器上增加吞吐量。

复制也是许多问题的根源，因为现在有多个数据的独立副本必须在多台机器上保持同步 - 这意味着确保复制遵循一致性模型。

一致性模型的选择至关重要：良好的一致性模型为程序员提供了清晰的语义（换句话说，它保证的属性很容易推理），并满足业务/设计目标，如高可用性或强一致性。

只有一个用于复制的一致性模型 - 强一致性 - 允许您编程为 - 如果底层数据未被复制。 其他一致性模型向程序员展示了一些内部的复制内容。 但是，一致性较弱的模型可以提供更低的延迟和更高的可用性，而且不一定更难以理解，只是不同而已。

### 进一步阅读

    作为计算机的数据中心 - 仓库秤机器设计介绍 - Barroso＆Hölzle，2008
    分布式计算的谬误
    关于青少年分布式系统的注释 - Hodges，2013